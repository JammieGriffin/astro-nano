---
title: '监听子组件的生命周期事件'
description: ' '
tags:
  - vue
date: '2025-08-12'
draft: true
---

import Link from '@components/Link.astro'

export const href = {
  mdnImport: 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/import',
  sourceCodeVon: 'https://github.com/vuejs/core/blob/main/packages/compiler-core/src/transforms/vOn.ts#L46',
  vuePlayground: 'https://play.vuejs.org/#__PROD__eNp9Ustu2zAQ/JUtL7KBVELRnlzZaFoEaAv0gbZAL7wI0tphQi0FPhQHgv49SzJObORxI3dmuDO7nMT5MJRjQLEStWutGjw49GHYSFL9YKyHCTrcKsJzd0vtF8NFQvIww9aaHgrWFh+PyBa3J5gkSa0h5yFqYf3sa4vFEtYbyI8sirKKSLRVLJePD/Rux3pusCi+otYG/huruzcFUzLBUNT9MIE8dkzNr06SIGrLsdEBuVyk5slPznKvYK+zpLrKc+AJ8MVjP+jGI98A6st3m2lKPua5rviWqoqG4GF825sO9VoKxqWAKoMp9SeOsupzFyac+Lyn1tVRK3EmvONMW7Urr5wh3k5KIUXLQqXR/hq84sxSrHK+iDU8k5vvqeZtwLNDvb3E9vqZ+pXbx5oUvy06tCNK8YD5xu7QZ/ji70/c8/kB5KBBM/sV8A86o0P0mGmfA3Vs+4iX3H5LG1e0++cu9h7JHUJFo5E5J74UPMA4s5eiP9p9X35IOt4lT/Hwj55879e23KkxHQCa9FHizBNQZeR0VfMdTHUZHw=='
}

`defineAsyncComponent` 是 Vue3 中异步导入组件的 API。
常见的用法是与 <Link href={href.mdnImport} external={true}>ES 模块动态导入</Link> 搭配使用。

通过 `defineAsyncComponent`，我们可以实现组件的按需加载、远程加载、懒加载等功能；在与 `import()` 动态导入搭配使用时，类似
Vite 和 Webpack 这类
构建工具在打包时会将动态导入的组件代码作为分割点分割成独立的 JS chunk，减少初始加载时的资源体积。

由于使用 `defineAsyncComponent` 导入的组件是异步加载的，组件的挂载时机会受到诸如网络延迟等因素的影响，因此，在通过 `ref`
引用调用异步组件实例暴露的方法时，我们需要
保证异步组件已经挂载，否则会遇到 `Cannot read properties of undefined` 错误。

那么该怎么去保证异步组件实例的方法被调用前组件已经挂载？

核心思路是在父组件创建一个 `Promise` 去控制它，在异步组件挂载后兑现这个 `Promise`，在调用异步组件实例方法的代码前等待这个
`Promise` 被兑现再继续执行。

因此我们很自然地就想到，在异步组件的 `onMounted` 钩子函数中，使用 `emit` 发出一个事件，让父组件去监听这个事件并兑现
`Promise`。

```vue
<!--异步导入的组件-->
<template>
  <div>
    <!-- 组件模板 -->
  </div>
</template>
<script setup>
  const emit = defineEmits < {
    mounted: []
  } > ()

  //  ... 组件逻辑

  const dosomething = () => {
    // ... do something
  }

  onMounted(() => {
    emit('mounted')
  })

  defineExpose({
    dosomething
  })
</script>

<!--父组件-->
<template>
  <div>
    <!-- 其它模板内容 -->
    <MyComponnet
      ref="myCompRef"
      @mounted="myCompResolver.resolve(myCompRef)"
    />
    <button @click="onClick">
      call MyComponent do something
    </button>
  </div>
</template>
<script setup>
  const MyComponent = defineAsyncComponent(
    () => import('/path/to/MyComponent.vue')
  )
  const myCompRef = ref()
  const myCompResolver = Promise.withResolvers()

  const onClick = async () => {
    const myComp = await myCompResolver.promise
    myComp.dosomething()
  }
</script>
```

在上面的代码中，我们通过 `Promise.withResolvers()` 创建了一个可以手动控制的 `Promise`，在异步组件的 `onMounted` 钩子中发出
`mounted` 事件，
父组件监听这个事件并兑现 `Promise`。在调用异步组件实例方法前，我们使用 `await` 等待这个 `Promise` 被兑现，确保异步组件已经挂载。
这样就可以安全地调用异步组件实例的方法了。

然而这种方式需要在异步组件内部写 `emit` 事件，在`onMounted`、`onUnmounted` 钩子回调中触发相应的事件，写多了会显得有些繁琐。

有没有更简洁的方式呢？

实际上 Vue 已经内置了这些组件生命周期的事件，我们可以通过 `@vue:` + 生命周期名称来监听子组件的生命周期事件，例如
`@vue:mounted`、`@vue:unmounted` 等。
因此我们可以直接在父组件中监听异步组件的生命周期事件，而不需要在异步组件内部写 `emit` 事件。

将上文中的代码稍微改造一下：

```vue
<!--异步导入的组件-->
<template>
  <div>
    <!-- 组件模板 -->
  </div>
</template>
<script setup>
  //  ... 组件逻辑

  const dosomething = () => {
    // ... do something
  }

  defineExpose({
    dosomething
  })
</script>

<!--父组件-->
<template>
  <div>
    <!-- 其它模板内容 -->
    <MyComponnet
      ref="myCompRef"
      @vue:mounted="myCompResolver.resolve(myCompRef)"
    />
    <button @click="onClick">
      call MyComponent do something
    </button>
  </div>
</template>
<script setup>
  const MyComponent = defineAsyncComponent(
    () => import('/path/to/MyComponent.vue')
  )
  const myCompRef = ref()
  const myCompResolver = Promise.withResolvers()

  const onClick = async () => {
    const myComp = await myCompResolver.promise
    myComp.dosomething()
  }
</script>
```

改造后的代码和改造前的代码相比，去掉了异步组件内部的 `emit` 事件，直接在父组件中监听异步组件的生命周期事件，代码更加简洁。

事实上，Vue 的官方文档并没有提及到这种方法去监听子组件的生命周期事件，但是 Vue 源码中确实有相关的实现。

在 SFC 中组件事件绑定是通过 `v-on` 指令实现的，因此我们可以从 `v-on` 指令的源码入手：

在 <Link href={href.sourceCodeVon} external={true}>
编译器对 vOn 指令转换
</Link> 的源码中，对于事件名称为 `vue:` 开头的事件名称会有一个分支处理，将 `vue:` 前缀去掉，拼接上 `vnode-`。

```ts
if (rawName.startsWith('vue:')) {
  rawName = `vnode-${rawName.slice(4)}`
}
```

之后将事件名称转换为 camelCase 格式，`@vue:mounted` 会被编译器编译为 `onVnodeMounted`

```typescript
const eventString =
  node.tagType !== ElementTypes.ELEMENT ||
  rawName.startsWith('vnode') ||
  !/[A-Z]/.test(rawName)
    ? toHandlerKey(camelize(rawName))
    : `on:${rawName}`
eventName = createSimpleExpression(eventString, true, arg.loc)
```

在 <Link href={href.vuePlayground}>Vue 演练场</Link> 中查看编译结果可以看到，`@vue:mounted` 被编译为 `onVnodeMounted`

![](@assets/attachment/25-08/vue-playground-sourcemap.png)

